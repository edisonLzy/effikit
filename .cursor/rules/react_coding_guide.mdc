---
description:
globs:
alwaysApply: false
---
# React ç»„ä»¶ç¼–å†™è§„èŒƒ

## **æ ¸å¿ƒåŸåˆ™**

### **1. è§†å›¾ä¸é€»è¾‘ä¸¥æ ¼åˆ†ç¦»**
- **è§†å›¾å±‚**ï¼šåªè´Ÿè´£ UI æ¸²æŸ“å’Œç”¨æˆ·äº¤äº’äº‹ä»¶ç»‘å®š
- **é€»è¾‘å±‚**ï¼šé€šè¿‡è‡ªå®šä¹‰ Hook å¤„ç†æ‰€æœ‰ä¸šåŠ¡é€»è¾‘ã€çŠ¶æ€ç®¡ç†ã€å‰¯ä½œç”¨
- **æ•°æ®å±‚**ï¼šé€šè¿‡ Hook ç®¡ç†æ•°æ®è·å–ã€ç¼“å­˜ã€åŒæ­¥

### **2. Hook First åŸåˆ™**
- **ä¼˜å…ˆä½¿ç”¨è‡ªå®šä¹‰ Hook** å°è£…æ‰€æœ‰é€»è¾‘
- **ç»„ä»¶å†…éƒ¨ç¦æ­¢ç›´æ¥å†™ä¸šåŠ¡é€»è¾‘**
- **æ¯ä¸ª Hook èŒè´£å•ä¸€ä¸”å¯å¤ç”¨**

## **ç»„ä»¶ç»“æ„è§„èŒƒ**

### **âœ… æ ‡å‡†ç»„ä»¶ç»“æ„**
```tsx
// âœ… æ­£ç¡®ç¤ºä¾‹ï¼šè§†å›¾ä¸é€»è¾‘åˆ†ç¦»
import React from 'react';
import { useToolManagement } from '@/hooks/useToolManagement';
import { useToolSearch } from '@/hooks/useToolSearch';
import { ToolList } from './ToolList';
import { SearchBar } from './SearchBar';

interface ToolManagerProps {
  initialTools?: Tool[];
}

export const ToolManager: React.FC<ToolManagerProps> = ({ 
  initialTools = [] 
}) => {
  // ğŸ¯ æ‰€æœ‰é€»è¾‘é€šè¿‡ Hook å¤„ç†
  const {
    tools,
    enabledTools,
    isLoading,
    error,
    toggleTool,
    refreshTools
  } = useToolManagement(initialTools);

  const {
    searchTerm,
    filteredTools,
    handleSearch,
    clearSearch
  } = useToolSearch(tools);

  // ğŸ¯ ç»„ä»¶åªè´Ÿè´£æ¸²æŸ“å’Œäº‹ä»¶ç»‘å®š
  if (isLoading) {
    return <div className="loading">åŠ è½½ä¸­...</div>;
  }

  if (error) {
    return <div className="error">é”™è¯¯: {error}</div>;
  }

  return (
    <div className="tool-manager">
      <SearchBar
        value={searchTerm}
        onChange={handleSearch}
        onClear={clearSearch}
        placeholder="æœç´¢å·¥å…·..."
      />
      <ToolList
        tools={filteredTools}
        enabledTools={enabledTools}
        onToggle={toggleTool}
        onRefresh={refreshTools}
      />
    </div>
  );
};
```

### **âŒ é”™è¯¯ç¤ºä¾‹ï¼šé€»è¾‘ä¸è§†å›¾æ··åˆ**
```tsx
// âŒ é”™è¯¯ç¤ºä¾‹ï¼šä¸è¦åœ¨ç»„ä»¶å†…ç›´æ¥å†™ä¸šåŠ¡é€»è¾‘
export const ToolManager: React.FC<ToolManagerProps> = ({ initialTools }) => {
  const [tools, setTools] = useState(initialTools);
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // âŒ ä¸è¦åœ¨ç»„ä»¶å†…ç›´æ¥å†™å¤æ‚é€»è¾‘
  const handleToggleTool = async (toolId: string) => {
    setIsLoading(true);
    try {
      const updatedTool = await api.toggleTool(toolId);
      setTools(prev => prev.map(tool => 
        tool.id === toolId ? updatedTool : tool
      ));
      await chrome.storage.local.set({ tools });
    } catch (error) {
      console.error('Toggle failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // âŒ ä¸è¦åœ¨ç»„ä»¶å†…ç›´æ¥å†™æœç´¢é€»è¾‘
  const filteredTools = useMemo(() => {
    return tools.filter(tool => 
      tool.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      tool.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [tools, searchTerm]);

  // æ¸²æŸ“é€»è¾‘...
};
```

## **Hook è®¾è®¡è§„èŒƒ**

### **1. è‡ªå®šä¹‰ Hook å‘½åè§„èŒƒ**
```tsx
// âœ… ä½¿ç”¨ use å‰ç¼€ + åŠŸèƒ½æè¿°
const useToolManagement = () => {};
const useToolSearch = () => {};
const useToolStorage = () => {};
const useToolValidation = () => {};
const useApiRequest = () => {};
```

### **2. Hook èŒè´£åˆ†ç¦»**
```tsx
// âœ… æ•°æ®ç®¡ç† Hook
const useToolData = (initialTools: Tool[]) => {
  const [tools, setTools] = useState<Tool[]>(initialTools);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const addTool = useCallback((tool: Tool) => {
    setTools(prev => [...prev, tool]);
  }, []);

  const removeTool = useCallback((toolId: string) => {
    setTools(prev => prev.filter(t => t.id !== toolId));
  }, []);

  const updateTool = useCallback((toolId: string, updates: Partial<Tool>) => {
    setTools(prev => prev.map(t => 
      t.id === toolId ? { ...t, ...updates } : t
    ));
  }, []);

  return {
    tools,
    isLoading,
    error,
    addTool,
    removeTool,
    updateTool
  };
};

// âœ… æœç´¢é€»è¾‘ Hook
const useToolSearch = (tools: Tool[]) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchHistory, setSearchHistory] = useState<string[]>([]);

  const filteredTools = useMemo(() => {
    if (!searchTerm.trim()) return tools;
    
    return tools.filter(tool => 
      tool.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      tool.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [tools, searchTerm]);

  const handleSearch = useCallback((term: string) => {
    setSearchTerm(term);
    if (term.trim() && !searchHistory.includes(term)) {
      setSearchHistory(prev => [term, ...prev.slice(0, 4)]);
    }
  }, [searchHistory]);

  const clearSearch = useCallback(() => {
    setSearchTerm('');
  }, []);

  return {
    searchTerm,
    searchHistory,
    filteredTools,
    handleSearch,
    clearSearch
  };
};

// âœ… å­˜å‚¨é€»è¾‘ Hook
const useToolStorage = () => {
  const saveTools = useCallback(async (tools: Tool[]) => {
    try {
      await chrome.storage.local.set({ tools });
    } catch (error) {
      console.error('ä¿å­˜å·¥å…·å¤±è´¥:', error);
      throw error;
    }
  }, []);

  const loadTools = useCallback(async (): Promise<Tool[]> => {
    try {
      const result = await chrome.storage.local.get('tools');
      return result.tools || [];
    } catch (error) {
      console.error('åŠ è½½å·¥å…·å¤±è´¥:', error);
      throw error;
    }
  }, []);

  return { saveTools, loadTools };
};
```

### **3. Hook ç»„åˆæ¨¡å¼**
```tsx
// âœ… ç»„åˆå¤šä¸ª Hook åˆ›å»ºé«˜çº§ Hook
const useToolManagement = (initialTools: Tool[]) => {
  const { tools, isLoading, error, addTool, removeTool, updateTool } = useToolData(initialTools);
  const { saveTools, loadTools } = useToolStorage();
  const [enabledTools, setEnabledTools] = useState<Record<string, boolean>>({});

  // åˆå§‹åŒ–åŠ è½½
  useEffect(() => {
    const initializeTools = async () => {
      try {
        const savedTools = await loadTools();
        if (savedTools.length > 0) {
          // ä½¿ç”¨ Hook æä¾›çš„æ–¹æ³•æ›´æ–°çŠ¶æ€
          savedTools.forEach(tool => addTool(tool));
        }
      } catch (error) {
        console.error('åˆå§‹åŒ–å·¥å…·å¤±è´¥:', error);
      }
    };

    initializeTools();
  }, [loadTools, addTool]);

  // å·¥å…·åˆ‡æ¢é€»è¾‘
  const toggleTool = useCallback(async (toolId: string) => {
    const newState = !enabledTools[toolId];
    setEnabledTools(prev => ({ ...prev, [toolId]: newState }));
    
    // æ›´æ–°å·¥å…·çŠ¶æ€
    updateTool(toolId, { enabled: newState });
    
    // ä¿å­˜åˆ°å­˜å‚¨
    try {
      await saveTools(tools);
    } catch (error) {
      // å›æ»šçŠ¶æ€
      setEnabledTools(prev => ({ ...prev, [toolId]: !newState }));
      updateTool(toolId, { enabled: !newState });
      throw error;
    }
  }, [enabledTools, tools, updateTool, saveTools]);

  const refreshTools = useCallback(async () => {
    try {
      const savedTools = await loadTools();
      // é‡æ–°è®¾ç½®å·¥å…·åˆ—è¡¨
      savedTools.forEach(tool => updateTool(tool.id, tool));
    } catch (error) {
      console.error('åˆ·æ–°å·¥å…·å¤±è´¥:', error);
    }
  }, [loadTools, updateTool]);

  return {
    tools,
    enabledTools,
    isLoading,
    error,
    toggleTool,
    refreshTools,
    addTool,
    removeTool
  };
};
```

## **ç»„ä»¶æ‹†åˆ†è§„èŒƒ**

### **1. æŒ‰åŠŸèƒ½æ‹†åˆ†ç»„ä»¶**
```tsx
// âœ… åŠŸèƒ½å•ä¸€çš„å°ç»„ä»¶
interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onClear: () => void;
  placeholder?: string;
}

export const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onClear,
  placeholder = "æœç´¢..."
}) => {
  return (
    <div className="search-bar">
      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="search-input"
      />
      {value && (
        <button onClick={onClear} className="clear-button">
          æ¸…ç©º
        </button>
      )}
    </div>
  );
};
```

### **2. å®¹å™¨ç»„ä»¶ä¸å±•ç¤ºç»„ä»¶åˆ†ç¦»**
```tsx
// âœ… å®¹å™¨ç»„ä»¶ï¼šè´Ÿè´£é€»è¾‘å’Œæ•°æ®
export const ToolManagerContainer: React.FC = () => {
  const toolManagement = useToolManagement([]);
  const toolSearch = useToolSearch(toolManagement.tools);

  return (
    <ToolManagerView
      {...toolManagement}
      {...toolSearch}
    />
  );
};

// âœ… å±•ç¤ºç»„ä»¶ï¼šåªè´Ÿè´£æ¸²æŸ“
interface ToolManagerViewProps {
  tools: Tool[];
  enabledTools: Record<string, boolean>;
  searchTerm: string;
  filteredTools: Tool[];
  isLoading: boolean;
  error: string | null;
  toggleTool: (toolId: string) => void;
  handleSearch: (term: string) => void;
  clearSearch: () => void;
}

export const ToolManagerView: React.FC<ToolManagerViewProps> = ({
  filteredTools,
  enabledTools,
  searchTerm,
  isLoading,
  error,
  toggleTool,
  handleSearch,
  clearSearch
}) => {
  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div className="tool-manager">
      <SearchBar
        value={searchTerm}
        onChange={handleSearch}
        onClear={clearSearch}
      />
      <ToolList
        tools={filteredTools}
        enabledTools={enabledTools}
        onToggle={toggleTool}
      />
    </div>
  );
};
```

## **çŠ¶æ€ç®¡ç†è§„èŒƒ**

### **1. æœ¬åœ°çŠ¶æ€ vs å…¨å±€çŠ¶æ€**
```tsx
// âœ… æœ¬åœ°çŠ¶æ€ï¼šç»„ä»¶å†…éƒ¨ä½¿ç”¨
const useLocalToggle = (initialValue = false) => {
  const [isOpen, setIsOpen] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setIsOpen(prev => !prev);
  }, []);

  const open = useCallback(() => setIsOpen(true), []);
  const close = useCallback(() => setIsOpen(false), []);

  return { isOpen, toggle, open, close };
};

// âœ… å…¨å±€çŠ¶æ€ï¼šè·¨ç»„ä»¶å…±äº«
const useGlobalToolState = () => {
  // ä½¿ç”¨ Context æˆ–çŠ¶æ€ç®¡ç†åº“
  const context = useContext(ToolContext);
  if (!context) {
    throw new Error('useGlobalToolState must be used within ToolProvider');
  }
  return context;
};
```

### **2. å‰¯ä½œç”¨å¤„ç†**
```tsx
// âœ… å‰¯ä½œç”¨å°è£…åœ¨ Hook ä¸­
const useToolSync = (tools: Tool[]) => {
  const { saveTools } = useToolStorage();

  // è‡ªåŠ¨åŒæ­¥å·¥å…·çŠ¶æ€
  useEffect(() => {
    const syncTools = async () => {
      try {
        await saveTools(tools);
      } catch (error) {
        console.error('åŒæ­¥å·¥å…·å¤±è´¥:', error);
      }
    };

    const timeoutId = setTimeout(syncTools, 1000); // é˜²æŠ–
    return () => clearTimeout(timeoutId);
  }, [tools, saveTools]);

  // ç›‘å¬å­˜å‚¨å˜åŒ–
  useEffect(() => {
    const handleStorageChange = (changes: any) => {
      if (changes.tools) {
        // å¤„ç†å¤–éƒ¨å­˜å‚¨å˜åŒ–
      }
    };

    chrome.storage.onChanged.addListener(handleStorageChange);
    return () => chrome.storage.onChanged.removeListener(handleStorageChange);
  }, []);
};
```

## **æ€§èƒ½ä¼˜åŒ–è§„èŒƒ**

### **1. è®°å¿†åŒ–ä¼˜åŒ–**
```tsx
// âœ… åœ¨ Hook ä¸­ä½¿ç”¨è®°å¿†åŒ–
const useOptimizedToolList = (tools: Tool[], searchTerm: string) => {
  const filteredTools = useMemo(() => {
    if (!searchTerm.trim()) return tools;
    
    return tools.filter(tool => 
      tool.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [tools, searchTerm]);

  const sortedTools = useMemo(() => {
    return [...filteredTools].sort((a, b) => a.name.localeCompare(b.name));
  }, [filteredTools]);

  return { filteredTools, sortedTools };
};

// âœ… å›è°ƒå‡½æ•°è®°å¿†åŒ–
const useToolActions = () => {
  const handleToolClick = useCallback((toolId: string) => {
    // å¤„ç†å·¥å…·ç‚¹å‡»
  }, []);

  const handleToolToggle = useCallback((toolId: string, enabled: boolean) => {
    // å¤„ç†å·¥å…·åˆ‡æ¢
  }, []);

  return { handleToolClick, handleToolToggle };
};
```

### **2. ç»„ä»¶è®°å¿†åŒ–**
```tsx
// âœ… å±•ç¤ºç»„ä»¶ä½¿ç”¨ memo
export const ToolItem = React.memo<ToolItemProps>(({
  tool,
  enabled,
  onToggle,
  onClick
}) => {
  return (
    <div className="tool-item" onClick={() => onClick(tool.id)}>
      <span>{tool.name}</span>
      <button onClick={(e) => {
        e.stopPropagation();
        onToggle(tool.id, !enabled);
      }}>
        {enabled ? 'ç¦ç”¨' : 'å¯ç”¨'}
      </button>
    </div>
  );
});

ToolItem.displayName = 'ToolItem';
```

## **é”™è¯¯å¤„ç†è§„èŒƒ**

### **1. Hook ä¸­çš„é”™è¯¯å¤„ç†**
```tsx
// âœ… ç»Ÿä¸€çš„é”™è¯¯å¤„ç† Hook
const useErrorHandler = () => {
  const [error, setError] = useState<string | null>(null);

  const handleError = useCallback((error: unknown) => {
    const message = error instanceof Error ? error.message : 'æœªçŸ¥é”™è¯¯';
    setError(message);
    console.error('ç»„ä»¶é”™è¯¯:', error);
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return { error, handleError, clearError };
};

// âœ… åœ¨ä¸šåŠ¡ Hook ä¸­ä½¿ç”¨é”™è¯¯å¤„ç†
const useToolManagement = () => {
  const { error, handleError, clearError } = useErrorHandler();
  
  const toggleTool = useCallback(async (toolId: string) => {
    try {
      clearError();
      // ä¸šåŠ¡é€»è¾‘
    } catch (err) {
      handleError(err);
    }
  }, [handleError, clearError]);

  return { error, toggleTool };
};
```

## **æµ‹è¯•å‹å¥½çš„è®¾è®¡**

### **1. Hook å¯æµ‹è¯•æ€§**
```tsx
// âœ… çº¯å‡½æ•° Hook æ˜“äºæµ‹è¯•
export const useToolFilter = (tools: Tool[], filters: FilterOptions) => {
  return useMemo(() => {
    return tools.filter(tool => {
      if (filters.enabled !== undefined && tool.enabled !== filters.enabled) {
        return false;
      }
      if (filters.category && tool.category !== filters.category) {
        return false;
      }
      return true;
    });
  }, [tools, filters]);
};

// âœ… ç»„ä»¶é€»è¾‘å¯ç‹¬ç«‹æµ‹è¯•
export const useToolManagementLogic = (initialTools: Tool[]) => {
  // æ‰€æœ‰é€»è¾‘éƒ½åœ¨è¿™é‡Œï¼Œå¯ä»¥ç‹¬ç«‹æµ‹è¯•
  // ä¸ä¾èµ– DOM æˆ– React æ¸²æŸ“
};
```

## **ç¦æ­¢çš„åæ¨¡å¼**

### **âŒ ä¸è¦åœ¨ç»„ä»¶ä¸­ç›´æ¥å†™ä¸šåŠ¡é€»è¾‘**
```tsx
// âŒ é”™è¯¯ï¼šç»„ä»¶å†…ç›´æ¥å¤„ç†å¤æ‚é€»è¾‘
const ToolManager = () => {
  const [tools, setTools] = useState([]);
  
  // âŒ ä¸è¦åœ¨ç»„ä»¶å†…ç›´æ¥å†™ API è°ƒç”¨
  const handleSave = async () => {
    const response = await fetch('/api/tools', {
      method: 'POST',
      body: JSON.stringify(tools)
    });
    // ...
  };

  // âŒ ä¸è¦åœ¨ç»„ä»¶å†…ç›´æ¥å†™å¤æ‚è®¡ç®—
  const expensiveCalculation = () => {
    // å¤æ‚è®¡ç®—é€»è¾‘
  };

  return <div>{/* JSX */}</div>;
};
```

### **âŒ ä¸è¦æ··åˆå¤šç§èŒè´£**
```tsx
// âŒ é”™è¯¯ï¼šä¸€ä¸ª Hook å¤„ç†å¤šç§ä¸ç›¸å…³çš„é€»è¾‘
const useEverything = () => {
  // âŒ ä¸è¦åœ¨ä¸€ä¸ª Hook ä¸­æ··åˆæ•°æ®è·å–ã€UI çŠ¶æ€ã€ä¸šåŠ¡é€»è¾‘
  const [tools, setTools] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [apiData, setApiData] = useState(null);
  
  // å¤ªå¤šä¸ç›¸å…³çš„é€»è¾‘...
};
```

## **æœ€ä½³å®è·µæ€»ç»“**

### **âœ… DOï¼ˆæ¨èåšæ³•ï¼‰**
- ä½¿ç”¨è‡ªå®šä¹‰ Hook å°è£…æ‰€æœ‰ä¸šåŠ¡é€»è¾‘
- ç»„ä»¶åªè´Ÿè´£æ¸²æŸ“å’Œäº‹ä»¶ç»‘å®š
- Hook èŒè´£å•ä¸€ï¼Œå¯å¤ç”¨
- ä½¿ç”¨ TypeScript ä¸¥æ ¼ç±»å‹æ£€æŸ¥
- åˆç†ä½¿ç”¨ useMemo å’Œ useCallback ä¼˜åŒ–æ€§èƒ½
- é”™è¯¯å¤„ç†ç»Ÿä¸€åœ¨ Hook ä¸­å¤„ç†

### **âŒ DON'Tï¼ˆç¦æ­¢åšæ³•ï¼‰**
- åœ¨ç»„ä»¶å†…ç›´æ¥å†™ä¸šåŠ¡é€»è¾‘
- åœ¨ç»„ä»¶å†…ç›´æ¥è°ƒç”¨ API
- åœ¨ç»„ä»¶å†…ç›´æ¥æ“ä½œ localStorage/Chrome Storage
- æ··åˆå¤šç§èŒè´£åœ¨ä¸€ä¸ª Hook ä¸­
- å¿½ç•¥é”™è¯¯å¤„ç†
- è¿‡åº¦ä¼˜åŒ–æˆ–è¿‡æ—©ä¼˜åŒ–

---

**éµå¾ªè¿™äº›è§„èŒƒå°†ç¡®ä¿ä»£ç çš„å¯ç»´æŠ¤æ€§ã€å¯æµ‹è¯•æ€§å’Œå¯å¤ç”¨æ€§ã€‚**
