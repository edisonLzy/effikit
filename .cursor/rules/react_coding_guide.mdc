---
description:
globs:
alwaysApply: false
---
# React 组件编写规范

## **核心原则**

### **1. 视图与逻辑严格分离**
- **视图层**：只负责 UI 渲染和用户交互事件绑定
- **逻辑层**：通过自定义 Hook 处理所有业务逻辑、状态管理、副作用
- **数据层**：通过 Hook 管理数据获取、缓存、同步

### **2. Hook First 原则**
- **优先使用自定义 Hook** 封装所有逻辑
- **组件内部禁止直接写业务逻辑**
- **每个 Hook 职责单一且可复用**

## **组件结构规范**

### **✅ 标准组件结构**
```tsx
// ✅ 正确示例：视图与逻辑分离
import React from 'react';
import { useToolManagement } from '@/hooks/useToolManagement';
import { useToolSearch } from '@/hooks/useToolSearch';
import { ToolList } from './ToolList';
import { SearchBar } from './SearchBar';

interface ToolManagerProps {
  initialTools?: Tool[];
}

export const ToolManager: React.FC<ToolManagerProps> = ({ 
  initialTools = [] 
}) => {
  // 🎯 所有逻辑通过 Hook 处理
  const {
    tools,
    enabledTools,
    isLoading,
    error,
    toggleTool,
    refreshTools
  } = useToolManagement(initialTools);

  const {
    searchTerm,
    filteredTools,
    handleSearch,
    clearSearch
  } = useToolSearch(tools);

  // 🎯 组件只负责渲染和事件绑定
  if (isLoading) {
    return <div className="loading">加载中...</div>;
  }

  if (error) {
    return <div className="error">错误: {error}</div>;
  }

  return (
    <div className="tool-manager">
      <SearchBar
        value={searchTerm}
        onChange={handleSearch}
        onClear={clearSearch}
        placeholder="搜索工具..."
      />
      <ToolList
        tools={filteredTools}
        enabledTools={enabledTools}
        onToggle={toggleTool}
        onRefresh={refreshTools}
      />
    </div>
  );
};
```

### **❌ 错误示例：逻辑与视图混合**
```tsx
// ❌ 错误示例：不要在组件内直接写业务逻辑
export const ToolManager: React.FC<ToolManagerProps> = ({ initialTools }) => {
  const [tools, setTools] = useState(initialTools);
  const [searchTerm, setSearchTerm] = useState('');
  const [isLoading, setIsLoading] = useState(false);

  // ❌ 不要在组件内直接写复杂逻辑
  const handleToggleTool = async (toolId: string) => {
    setIsLoading(true);
    try {
      const updatedTool = await api.toggleTool(toolId);
      setTools(prev => prev.map(tool => 
        tool.id === toolId ? updatedTool : tool
      ));
      await chrome.storage.local.set({ tools });
    } catch (error) {
      console.error('Toggle failed:', error);
    } finally {
      setIsLoading(false);
    }
  };

  // ❌ 不要在组件内直接写搜索逻辑
  const filteredTools = useMemo(() => {
    return tools.filter(tool => 
      tool.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      tool.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [tools, searchTerm]);

  // 渲染逻辑...
};
```

## **Hook 设计规范**

### **1. 自定义 Hook 命名规范**
```tsx
// ✅ 使用 use 前缀 + 功能描述
const useToolManagement = () => {};
const useToolSearch = () => {};
const useToolStorage = () => {};
const useToolValidation = () => {};
const useApiRequest = () => {};
```

### **2. Hook 职责分离**
```tsx
// ✅ 数据管理 Hook
const useToolData = (initialTools: Tool[]) => {
  const [tools, setTools] = useState<Tool[]>(initialTools);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const addTool = useCallback((tool: Tool) => {
    setTools(prev => [...prev, tool]);
  }, []);

  const removeTool = useCallback((toolId: string) => {
    setTools(prev => prev.filter(t => t.id !== toolId));
  }, []);

  const updateTool = useCallback((toolId: string, updates: Partial<Tool>) => {
    setTools(prev => prev.map(t => 
      t.id === toolId ? { ...t, ...updates } : t
    ));
  }, []);

  return {
    tools,
    isLoading,
    error,
    addTool,
    removeTool,
    updateTool
  };
};

// ✅ 搜索逻辑 Hook
const useToolSearch = (tools: Tool[]) => {
  const [searchTerm, setSearchTerm] = useState('');
  const [searchHistory, setSearchHistory] = useState<string[]>([]);

  const filteredTools = useMemo(() => {
    if (!searchTerm.trim()) return tools;
    
    return tools.filter(tool => 
      tool.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
      tool.description.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [tools, searchTerm]);

  const handleSearch = useCallback((term: string) => {
    setSearchTerm(term);
    if (term.trim() && !searchHistory.includes(term)) {
      setSearchHistory(prev => [term, ...prev.slice(0, 4)]);
    }
  }, [searchHistory]);

  const clearSearch = useCallback(() => {
    setSearchTerm('');
  }, []);

  return {
    searchTerm,
    searchHistory,
    filteredTools,
    handleSearch,
    clearSearch
  };
};

// ✅ 存储逻辑 Hook
const useToolStorage = () => {
  const saveTools = useCallback(async (tools: Tool[]) => {
    try {
      await chrome.storage.local.set({ tools });
    } catch (error) {
      console.error('保存工具失败:', error);
      throw error;
    }
  }, []);

  const loadTools = useCallback(async (): Promise<Tool[]> => {
    try {
      const result = await chrome.storage.local.get('tools');
      return result.tools || [];
    } catch (error) {
      console.error('加载工具失败:', error);
      throw error;
    }
  }, []);

  return { saveTools, loadTools };
};
```

### **3. Hook 组合模式**
```tsx
// ✅ 组合多个 Hook 创建高级 Hook
const useToolManagement = (initialTools: Tool[]) => {
  const { tools, isLoading, error, addTool, removeTool, updateTool } = useToolData(initialTools);
  const { saveTools, loadTools } = useToolStorage();
  const [enabledTools, setEnabledTools] = useState<Record<string, boolean>>({});

  // 初始化加载
  useEffect(() => {
    const initializeTools = async () => {
      try {
        const savedTools = await loadTools();
        if (savedTools.length > 0) {
          // 使用 Hook 提供的方法更新状态
          savedTools.forEach(tool => addTool(tool));
        }
      } catch (error) {
        console.error('初始化工具失败:', error);
      }
    };

    initializeTools();
  }, [loadTools, addTool]);

  // 工具切换逻辑
  const toggleTool = useCallback(async (toolId: string) => {
    const newState = !enabledTools[toolId];
    setEnabledTools(prev => ({ ...prev, [toolId]: newState }));
    
    // 更新工具状态
    updateTool(toolId, { enabled: newState });
    
    // 保存到存储
    try {
      await saveTools(tools);
    } catch (error) {
      // 回滚状态
      setEnabledTools(prev => ({ ...prev, [toolId]: !newState }));
      updateTool(toolId, { enabled: !newState });
      throw error;
    }
  }, [enabledTools, tools, updateTool, saveTools]);

  const refreshTools = useCallback(async () => {
    try {
      const savedTools = await loadTools();
      // 重新设置工具列表
      savedTools.forEach(tool => updateTool(tool.id, tool));
    } catch (error) {
      console.error('刷新工具失败:', error);
    }
  }, [loadTools, updateTool]);

  return {
    tools,
    enabledTools,
    isLoading,
    error,
    toggleTool,
    refreshTools,
    addTool,
    removeTool
  };
};
```

## **组件拆分规范**

### **1. 按功能拆分组件**
```tsx
// ✅ 功能单一的小组件
interface SearchBarProps {
  value: string;
  onChange: (value: string) => void;
  onClear: () => void;
  placeholder?: string;
}

export const SearchBar: React.FC<SearchBarProps> = ({
  value,
  onChange,
  onClear,
  placeholder = "搜索..."
}) => {
  return (
    <div className="search-bar">
      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className="search-input"
      />
      {value && (
        <button onClick={onClear} className="clear-button">
          清空
        </button>
      )}
    </div>
  );
};
```

### **2. 容器组件与展示组件分离**
```tsx
// ✅ 容器组件：负责逻辑和数据
export const ToolManagerContainer: React.FC = () => {
  const toolManagement = useToolManagement([]);
  const toolSearch = useToolSearch(toolManagement.tools);

  return (
    <ToolManagerView
      {...toolManagement}
      {...toolSearch}
    />
  );
};

// ✅ 展示组件：只负责渲染
interface ToolManagerViewProps {
  tools: Tool[];
  enabledTools: Record<string, boolean>;
  searchTerm: string;
  filteredTools: Tool[];
  isLoading: boolean;
  error: string | null;
  toggleTool: (toolId: string) => void;
  handleSearch: (term: string) => void;
  clearSearch: () => void;
}

export const ToolManagerView: React.FC<ToolManagerViewProps> = ({
  filteredTools,
  enabledTools,
  searchTerm,
  isLoading,
  error,
  toggleTool,
  handleSearch,
  clearSearch
}) => {
  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage message={error} />;

  return (
    <div className="tool-manager">
      <SearchBar
        value={searchTerm}
        onChange={handleSearch}
        onClear={clearSearch}
      />
      <ToolList
        tools={filteredTools}
        enabledTools={enabledTools}
        onToggle={toggleTool}
      />
    </div>
  );
};
```

## **状态管理规范**

### **1. 本地状态 vs 全局状态**
```tsx
// ✅ 本地状态：组件内部使用
const useLocalToggle = (initialValue = false) => {
  const [isOpen, setIsOpen] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setIsOpen(prev => !prev);
  }, []);

  const open = useCallback(() => setIsOpen(true), []);
  const close = useCallback(() => setIsOpen(false), []);

  return { isOpen, toggle, open, close };
};

// ✅ 全局状态：跨组件共享
const useGlobalToolState = () => {
  // 使用 Context 或状态管理库
  const context = useContext(ToolContext);
  if (!context) {
    throw new Error('useGlobalToolState must be used within ToolProvider');
  }
  return context;
};
```

### **2. 副作用处理**
```tsx
// ✅ 副作用封装在 Hook 中
const useToolSync = (tools: Tool[]) => {
  const { saveTools } = useToolStorage();

  // 自动同步工具状态
  useEffect(() => {
    const syncTools = async () => {
      try {
        await saveTools(tools);
      } catch (error) {
        console.error('同步工具失败:', error);
      }
    };

    const timeoutId = setTimeout(syncTools, 1000); // 防抖
    return () => clearTimeout(timeoutId);
  }, [tools, saveTools]);

  // 监听存储变化
  useEffect(() => {
    const handleStorageChange = (changes: any) => {
      if (changes.tools) {
        // 处理外部存储变化
      }
    };

    chrome.storage.onChanged.addListener(handleStorageChange);
    return () => chrome.storage.onChanged.removeListener(handleStorageChange);
  }, []);
};
```

## **性能优化规范**

### **1. 记忆化优化**
```tsx
// ✅ 在 Hook 中使用记忆化
const useOptimizedToolList = (tools: Tool[], searchTerm: string) => {
  const filteredTools = useMemo(() => {
    if (!searchTerm.trim()) return tools;
    
    return tools.filter(tool => 
      tool.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [tools, searchTerm]);

  const sortedTools = useMemo(() => {
    return [...filteredTools].sort((a, b) => a.name.localeCompare(b.name));
  }, [filteredTools]);

  return { filteredTools, sortedTools };
};

// ✅ 回调函数记忆化
const useToolActions = () => {
  const handleToolClick = useCallback((toolId: string) => {
    // 处理工具点击
  }, []);

  const handleToolToggle = useCallback((toolId: string, enabled: boolean) => {
    // 处理工具切换
  }, []);

  return { handleToolClick, handleToolToggle };
};
```

### **2. 组件记忆化**
```tsx
// ✅ 展示组件使用 memo
export const ToolItem = React.memo<ToolItemProps>(({
  tool,
  enabled,
  onToggle,
  onClick
}) => {
  return (
    <div className="tool-item" onClick={() => onClick(tool.id)}>
      <span>{tool.name}</span>
      <button onClick={(e) => {
        e.stopPropagation();
        onToggle(tool.id, !enabled);
      }}>
        {enabled ? '禁用' : '启用'}
      </button>
    </div>
  );
});

ToolItem.displayName = 'ToolItem';
```

## **错误处理规范**

### **1. Hook 中的错误处理**
```tsx
// ✅ 统一的错误处理 Hook
const useErrorHandler = () => {
  const [error, setError] = useState<string | null>(null);

  const handleError = useCallback((error: unknown) => {
    const message = error instanceof Error ? error.message : '未知错误';
    setError(message);
    console.error('组件错误:', error);
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  return { error, handleError, clearError };
};

// ✅ 在业务 Hook 中使用错误处理
const useToolManagement = () => {
  const { error, handleError, clearError } = useErrorHandler();
  
  const toggleTool = useCallback(async (toolId: string) => {
    try {
      clearError();
      // 业务逻辑
    } catch (err) {
      handleError(err);
    }
  }, [handleError, clearError]);

  return { error, toggleTool };
};
```

## **测试友好的设计**

### **1. Hook 可测试性**
```tsx
// ✅ 纯函数 Hook 易于测试
export const useToolFilter = (tools: Tool[], filters: FilterOptions) => {
  return useMemo(() => {
    return tools.filter(tool => {
      if (filters.enabled !== undefined && tool.enabled !== filters.enabled) {
        return false;
      }
      if (filters.category && tool.category !== filters.category) {
        return false;
      }
      return true;
    });
  }, [tools, filters]);
};

// ✅ 组件逻辑可独立测试
export const useToolManagementLogic = (initialTools: Tool[]) => {
  // 所有逻辑都在这里，可以独立测试
  // 不依赖 DOM 或 React 渲染
};
```

## **禁止的反模式**

### **❌ 不要在组件中直接写业务逻辑**
```tsx
// ❌ 错误：组件内直接处理复杂逻辑
const ToolManager = () => {
  const [tools, setTools] = useState([]);
  
  // ❌ 不要在组件内直接写 API 调用
  const handleSave = async () => {
    const response = await fetch('/api/tools', {
      method: 'POST',
      body: JSON.stringify(tools)
    });
    // ...
  };

  // ❌ 不要在组件内直接写复杂计算
  const expensiveCalculation = () => {
    // 复杂计算逻辑
  };

  return <div>{/* JSX */}</div>;
};
```

### **❌ 不要混合多种职责**
```tsx
// ❌ 错误：一个 Hook 处理多种不相关的逻辑
const useEverything = () => {
  // ❌ 不要在一个 Hook 中混合数据获取、UI 状态、业务逻辑
  const [tools, setTools] = useState([]);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [searchTerm, setSearchTerm] = useState('');
  const [apiData, setApiData] = useState(null);
  
  // 太多不相关的逻辑...
};
```

## **最佳实践总结**

### **✅ DO（推荐做法）**
- 使用自定义 Hook 封装所有业务逻辑
- 组件只负责渲染和事件绑定
- Hook 职责单一，可复用
- 使用 TypeScript 严格类型检查
- 合理使用 useMemo 和 useCallback 优化性能
- 错误处理统一在 Hook 中处理

### **❌ DON'T（禁止做法）**
- 在组件内直接写业务逻辑
- 在组件内直接调用 API
- 在组件内直接操作 localStorage/Chrome Storage
- 混合多种职责在一个 Hook 中
- 忽略错误处理
- 过度优化或过早优化

---

**遵循这些规范将确保代码的可维护性、可测试性和可复用性。**
